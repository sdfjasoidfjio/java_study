객체 지향 특성: 캡슐화
-> 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
------------------------------------------------------------------------

클래스: 객체 모양을 선언한 틀(캡슐화)
        메소드(멤버함수)와 필드(멤버 변수)는 모두 클래스 내에 구현
객체: 클래스의 모양대로 생선된 실체
      객체 내 데이터에 대한 보호, 외부 접근 제한

------------------------------------------------------------------------

객체 지향의 특성: 상속
상속: 상위 개체의 속성이 하위 개체에 물려짐
      하위 개체가 상위 개체의 속성을 모두 가지는 관계
실세계의 상속 사례: 유전적 사례

------------------------------------------------------------------------

클래스와 객체
클래스
- 객체를 만들어내기 위한 설계도 혹은 틀
- 객체의 속성과 행동 포함
객체
-클래스의 모양 그대로 찍어낸 실체
사례
-클래스: 붕어빵 틀, 객체: 구어낸 붕어빵들

------------------------------------------------------------------------

기본 생성자
- 매개 변수 없고 아무 작업 없이 단순 리턴하는 생성자
- 디폴트 생성자라고도 부름
- 클래스에 생성자가 하나도 선언되지 않은 경우, 컴파일러에 의해 자동으로 삽입

기본 생성자가 자동 생성되지 않는 경우
- 개발자가 클래스에 생성자가 하나라도 작성한 경우

------------------------------------------------------------------------

this 레퍼런스
- 객체 자신에 대한 레퍼런스
- 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
- this.멤버 형태로 멤버 사용하기만 하면 됨

- this.radius에서 radius는 객체 자신에 있는 멤버
- public Circle(int radius)에서 radius는 외부에서 받은 수

this가 필요한 이유
- 객체의 멤버 변수와 메소드 변수의 이름이 같은 경우
- 다른 메소드 호출 시 객체 자신의 레퍼런스를 전달할 때
- 메소드가 객체 자신의 레퍼런스를 반환할 때

this()로 다른 생성자 호출
- 클래스 내의 다른 생성자 호출
- 생성자 내에서만 사용 가능
- 반드시 생성자 코드의 제일 처음에 수행

------------------------------------------------------------------------

인자 전달
1. 기본 타입의 값 전달
- 매개 변수가 byte, int, double 등 기본 타입의 값일 때
    호출자가 거네는 값이 매개변수에 복사되어 전달(실인자 값은 변경되지 않음)
2. 객체가 전달되는 경우
- 객체의 레퍼런스만 전달
    매개 변수가 실인자 객체 공유
3. 배열이 전달되는 경우
- 배열 레퍼런스만 매개 변수에 전달
    배열 통째로 전달되지 않음
    객체가 전달되는 경우와 동일
    매개변수가 실인자의 배열을 공유

------------------------------------------------------------------------

메소드 오버로딩
- 이름이 같은 메소드 작성, 다음 2개의 조건
1. 매개변수의 개수나 타입이 서로 다르고
2. 이름이 동일한 메소드들
-리턴 타입은 오버로딩과 관련 없음

------------------------------------------------------------------------

non-static멤버의 특성
- 공간적 특성 - 멤버들은 객체마다 독립적으로 별도 존재
- 시간적 특성 - 필드와 메소드는 객체 생성 후 비로소 사용 가능
- 비공유 특성 - 멤버들은 다른 객체에 의해 공유되지 않고 배타적

static멤버란?
- 모든 객체가 공유하는 변수!!!
- 객체마다 생기는 것이 아님
- 클래스당 하나만 생성됨(클래스 멤버라고도 부름)
- 객체를 생성하지 않고 사용 가능
- 공간적 특성: 클래스 당 하나만 생성
- 시간적 특성: 클래스가 로딩될 때 공간 할당
- 공유의 특성: 동일한 클래스의 모든 객체에 의해 공유

------------------------------------------------------------------------

final 클래스와 메소드
- final 클래스 -> 클래스 상속 불가
- final 메소드 -> 오버라이딩 불가
- final 필드, 상수 선언 
    1. 상수를 선언할 때 사용
    2. 상수 필드는 선언 시에 초기 값을 지정하여야 함
    3. 상수 필드는 실행 중에 값을 변경할 수 없음